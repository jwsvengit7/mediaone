package com.example.test.ServiceImpl;import com.example.test.Config.JwtService;import com.example.test.Entity.Token;import com.example.test.Entity.User;import com.example.test.Enums.Role;import com.example.test.Exceptions.EmailAddressAlreadyExistException;import com.example.test.Repositories.TokenRepository;import com.example.test.Repositories.UserRepository;import com.example.test.Request.RegisterRequest;import com.example.test.Request.UserDTO;import com.example.test.Request.UserRequest;import com.example.test.Response.Response;import com.example.test.Services.UserService;import com.example.test.Token.TokenType;import com.fasterxml.jackson.databind.ObjectMapper;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import jakarta.servlet.http.HttpSession;import jakarta.transaction.Transactional;import lombok.RequiredArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.modelmapper.ModelMapper;import org.springframework.http.HttpHeaders;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import java.io.IOException;import java.util.List;@Service    @Slf4j    @RequiredArgsConstructor    public class UserServiceImplentation implements UserService {        private final UserRepository repository;        private final TokenRepository tokenRepository;        private final PasswordEncoder passwordEncoder;        private final JwtService jwtService;        private final AuthenticationManager authenticationManager;        private final EmailSenderImplementation emailSenderImplementation;        private final ModelMapper modelMapper;        @Override        @Transactional(rollbackOn = Exception.class)        public Response register(RegisterRequest request) {         User users =repository.findByEmail(request.getEmail()).orElse(null);         if(users!=null){             throw new EmailAddressAlreadyExistException("EMAIL ALREADY EXIST");         }            User user = User.builder()                    .email(request.getEmail())                    .password(passwordEncoder.encode(request.getPassword()))                    .role(Role.USER)                    .username(request.getUsername())                    .activate(false)                    .build();         repository.save(user);            String jwtToken = jwtService.generateToken(user);            String refreshToken = jwtService.generateRefreshToken(user);            revokeAllUserTokens(user);            saveUserToken(user, jwtToken);            System.out.println(jwtToken);            System.out.println(refreshToken);            emailSenderImplementation.sendEmail(jwtToken);             return Response.builder()                    .accessToken(jwtToken)                    .message("SUCCESS")                    .data(user)                    .build();        }        @Override        @Transactional(rollbackOn = Exception.class)        public Response authenticate(UserRequest request) {            authenticationManager.authenticate(                    new UsernamePasswordAuthenticationToken(                            request.getEmail(),                            request.getPassword()                    )            );            User user = repository.findByEmail(request.getEmail())                    .orElseThrow(()->{                      throw new RuntimeException("INVALID DETAILS");                    });            if(!user.isActivate()){                throw  new RuntimeException("ERROR");            }else {                String jwtToken = jwtService.generateToken(user);                String refreshToken = jwtService.generateRefreshToken(user);                revokeAllUserTokens(user);                saveUserToken(user, jwtToken);                return Response.builder()                        .accessToken(jwtToken)                        .refreshToken(refreshToken)                        .message("SUCCESS")                        .data(user)                        .build();            }        }       private void saveUserToken(User user, String jwtToken) {            Token token = Token.builder()                    .user(user)                    .token(jwtToken)                    .tokenType(TokenType.BEARER)                    .expired(false)                    .revoked(false)                    .build();            tokenRepository.save(token);        }        private void revokeAllUserTokens(User user) {            List<Token> validUserTokens = tokenRepository.findAllValidTokenByUser(user.getId());            if (validUserTokens.isEmpty())                return;            validUserTokens.forEach(token -> {                token.setExpired(true);                token.setRevoked(true);            });            tokenRepository.saveAll(validUserTokens);        }        public void refreshToken(                HttpServletRequest request,                HttpServletResponse response        ) throws IOException {            final String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);            final String refreshToken;            final String userEmail;            if (authHeader == null ||!authHeader.startsWith("Bearer ")) {                return;            }            refreshToken = authHeader.substring(7);            userEmail = jwtService.extractUsername(refreshToken);            if (userEmail != null) {                User user = this.repository.findByEmail(userEmail)                        .orElseThrow();                if (jwtService.isTokenValid(refreshToken, user)) {                    String accessToken = jwtService.generateToken(user);                    revokeAllUserTokens(user);                    saveUserToken(user, accessToken);                    Response authResponse = Response.builder()                            .accessToken(accessToken)                            .refreshToken(refreshToken)                            .build();                    new ObjectMapper().writeValue(response.getOutputStream(), authResponse);                }            }        }    }